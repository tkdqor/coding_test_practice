n = int(input())
a = list(map(int, input().split()))

def reverse(x):
    res = 0
    while x > 0:
        t = x % 10
        res = (res * 10) + t
        x = x // 10
    return res

def isPrime(x):
    if x == 1:
        return False
    for i in range(2, (x//2)+1):
        # x를 i로 나눌 때 나머지가 0이라면 약수가 존재한다는 의미니까 소수가 될 수 없으니 False를 리턴
        if x % i == 0:
            return False
    return True

for x in a:
    tmp = reverse(x)
    if isPrime(tmp):
        print(tmp, end=' ')


'''
주어진 수를 뒤집은 함수를 정의하기 위해서는, t라는 변수에다가 x % 10를 한다. 그리고 res = 0 이라고 정의하고 res = (res * 10) + t 이렇게 설정한다.
t라는 변수로 주어진 수의 한자리씩 선택하고, res 식은 기존의 뒤집은 숫자를 * 10해서 한자리씩 증가시켜주고 새롭게 뒤집은 수를 일의자리로 하기 위해 더해주는 것이다.

만약 주어진 수 x가 9010이라고 한다면, t는 0이 된다. 이 t를 위의 res 식에다가 대입하면 res는 0이 된다. 즉, 첫 자리부터의 0은 무시하는 것이다.
그 다음에는 주어진 수 x를 901로 바꿔준다. x = x // 10으로 해준다. 이 상태에서 t는 1이 되고, res 식에다가 대입하면 res는 1이 된다.
그 다음에는 주어진 수 x를 90으로 바꿔준다. 그러면 t는 0이 되고 res 식에다가 대입하면 res = 1*10 + 0 = 10이 된다.
그 다음에는 주어진 수 x를 9로 바꿔준다. 그러면 t는 9가 되고 res 식에다가 대입하면 res = 10*10 + 9 = 109가 된다.
이렇게 res 값이 주어진 수를 뒤집은 수가 된다.

16이라는 수가 주어졌을 때, 소수인지 확인하려면 16이 약수가 있는지 보면 된다. 1과 16 자기자신을 빼고 약수는 자기자신 절반인 8까지에서 존재하게 된다. 
16의 약수를 구하라고 하면 1*16, 2*8이니까 소수인지 확인할 때는 절반까지만 for문으로 확인하면 된다. 
그래서 16를 2부터 8까지 차례대로 나눴을 때의 나머지가 0이 하나라도 된다면 16은 약수가 있으니 소수가 될 수 없다.
'''
